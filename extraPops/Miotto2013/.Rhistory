data <- read.delim("~/Dropbox/Jess_PIP_GWAS/3D7-Sal1-hg19_VENN/test_for_python.sam", header=F)
View(data)
data
install.packages(c("ggplot2", "labeling", "maps", "plyr", "reshape2", "RSvgDevice", "scales"))
install.packages("knitr")
chr1 <- read.delim("~/Desktop/trf_work/chr1.txt", header=F)
View(chr1)
?aggregate
?tapply
install.packages("ggplot2")
install.packages("Rcpp")
install.packages("ggplot2")
library("codetools", lib.loc="/usr/lib/R/library")
remove.packages("codetools", lib="/usr/lib/R/library")
install.packages("codetools")
install.packages("Rcpp")
install.packages("ggplot2")
remove.packages("MASS", lib="/usr/lib/R/library")
install.packages("MASS")
install.packages("ggplot2")
library(ggplot2)
pvalues <- read.table("fet.igv", header=TRUE)
dd1 <- pvalues[grep("Pf3D7", pvalues$Chromosome), ] # grep for nuclear chrs
dd2 <- pvalues[with(dd1, order(Chromosome)), ] # order by chr
dd2$index <- 0:(length(dd2$Chromosome)-1) # add index
qplot(index, X1.2, data=dd2, color=Chromosome)
data$time <- c(0,45,90,150,195,230,265,290,313,199)
data <- c(0,45,90,150,195,230,265,290,313,399)
data
data <- null
data <- NA
time <- c(0,45,90,150,195,230,265,290,313,399)
sterile1 <- c(40,41,39,40,38,40,40,39,39,39)
data <- cbind(time,sterile1)
data
data$sterile2 <- c(38,38,38,39,37,39,40,40,40,45)
data
data <- cbind(time,sterile1)
data$sterile2 <- cbind(38,38,38,39,37,39,40,40,40,45)
data
data <- cbind(time,sterile1,sterile2)
sterile2 <- cbind(38,38,38,39,37,39,40,40,40,45)
data <- cbind(time,sterile1,sterile2)
data
data <- na
data <- NA
data <- cbind(time,sterile1,sterile2)
data <- cbind(sterile1,sterile2)
data <- cbind(time,sterile1)
sterile2
sterile2 <- c(38,38,38,39,37,39,40,40,40,45)
data <- cbind(time,sterile1,sterile2)
data
turbid1 <- c(40,42,43,50,55,66,75,80,82,84)
turbid2 <- c(41,41,42,50,53,69,73,78,79,83)
data <- cbind(time,sterile1,sterile2,turbid1,turbid2)
data
library(ggplot21)
library(ggplot2)
qplot <- qplot(turbid1, time, data=data)
args(ggplot2)
args(qplot)
plot(data$time ~ data$turbid1)
data$time
data
data$sterile1
class(data)
df <- data.frame(data)
df
qplot(time, turbid1, data=df)
args(qplot)
qplot(time, turbid1, data=df, geom="lines")
qplot(time, turbid1, data=df, geom="line")
qplot(time, turbid1, data=df, geom="smooth")
qplot(time, turbid1, data=df, geom=c("point","smooth")
)
qplot(time, turbid1, data=df, geom=c("point","smooth"))
View(df)
data$turbid <- paste(data[,4], data[,5])
data
data <- cbind(time,sterile1,sterile2,turbid1,turbid2)
data$turbid <- cbind(data, paste(data[,4], data[,5]))
data
names(data)
data <- cbind(time,sterile1,sterile2,turbid1,turbid2)
qplot(time, turbid1, data=df, geom=c("point","smooth"))
qplot(time, turbid1, data=df, geom=c("point","smooth")) + geom_line(aes(y=df$turbid2))
qplot(time, turbid1, data=df, geom=c("point","smooth")) + geom_smooth(aes(y=df$turbid2))
qplot(time, turbid1, data=df, geom=c("point","smooth")) + geom_smooth(aes(y=df$turbid2)) + geom_point(aes(y=df$turbid2))
df$sterile1 <- df$sterile1/0.049
df
df$sterile <- (df$sterile1 + df$sterile2)/2
df$turbid <- (df$turbid1 + df$turbid2)/2
df
data <- cbind(time,sterile1,sterile2,turbid1,turbid2)
df <- data.frame(data)
df$sterile <- (df$sterile1 + df$sterile2)/2
df$turbid <- (df$turbid1 + df$turbid2)/2
df
df$growth <- turbid-sterile
df$growth <- df$turbid - df$sterile
df
df$sterile <- (df$sterile1 + df$sterile2)/2/100
df$turbid <- (df$turbid1 + df$turbid2)/2/100
df
data <- cbind(time,sterile1,sterile2,turbid1,turbid2)
df <- data.frame(data)
df$sterile <- (df$sterile1 + df$sterile2)/2/1000
df$turbid <- (df$turbid1 + df$turbid2)/2/1000
df
df$sterile/0.049
df$turbid/0.049
(df$turbid - df$sterile )/0.049
qplot(time, turbid1, data=df, geom=c("point","smooth")) + geom_smooth(aes(y=df$turbid2))
args(qplot)
vcf <- read.table("combined.filtered.vcf", comment.char = "#")
install.packages("Rmpi")
install.packages(c("digest", "highr", "knitr", "MASS", "RColorBrewer", "Rcpp", "reshape2"))
install.packages("ParallelStructure")
install.packages("sarallelstructure")
install.packages("parallelstructure")
install.packages("ParallelStructure", repos="http://R-Forge.R-project.org")
library("ParallelStructure", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.1")
install.packages("rmpi")
install.packages("Rmpi")
install.packages("Rmpi")
install.packages("Rmpi")
library("bitops", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.1")
genome10 <- read.delim("~/Desktop/genome10.txt", header=FALSE)
View(genome10)
hist(gnome10)
hist(genome10)
hist(genome10$V2)
genome10$V3 <- 1:48
dim(genome10)
genome10
plot(genome10$V2 ~ genome10$V3)
1:48
plot(genome10$V2 ~ genome10$V1)
genome10 <- genome10[with(genome10, order(V2)), ]
genome10 <- genome10[with(genome10, order(V2)), ]
plot(genome10$V2 ~ genome10$V1)
genome10\
genome10
plot(data$X10xCov ~ data$number, axes=FALSE, xlab="Sample ID", ylab="Fraction of Genome Covered", ylim=c(0,1))
plot(genome10$V2 ~ genome10$V3, axes=FALSE, xlab="Sample ID", ylab="Fraction of Genome Covered", ylim=c(0,1))
plot(genome10$V2 ~ genome10$V3, axes=FALSE, xlab="Sample ID", ylab="Fraction of Genome Covered", ylim=c(0,1))
genome10 <- genome10[with(genome10, order(V2)), ]
genome10$V3 <- 1:48
plot(genome10$V2 ~ genome10$V3, axes=FALSE, xlab="Sample ID", ylab="Fraction of Genome Covered", ylim=c(0,1))
axis(1, at=1:48, labels=genome10$V1, cex.lab=0.7)
plot(genome10$V2 ~ genome10$V3, axes=FALSE, xlab="Sample ID", ylab="Fraction of Genome Covered", ylim=c(0,1))
axis(1, at=1:48, labels=genome10$V1, cex.lab=0.5)
plot(genome10$V2 ~ genome10$V3, axes=FALSE, xlab="Sample ID", ylab="Fraction of Genome Covered", ylim=c(0,1))
axis(1, at=1:48, labels=genome10$V1, cex.lab=0.1)
axis(2, at=c(0.0,0.2,0.4,0.6,0.8,1.0))
plot(genome10$V2 ~ genome10$V3, axes=FALSE, xlab="Sample ID", ylab="Fraction of Genome Covered", ylim=c(0,1), col="red")
axis(1, at=1:48, labels=genome10$V1, cex.lab=0.1)
axis(2, at=c(0.0,0.2,0.4,0.6,0.8,1.0))
plot(genome10$V2 ~ genome10$V3, axes=FALSE, xlab="Sample ID", ylab="Fraction of Genome Covered", ylim=c(0,1), col="red", pch=18)
axis(1, at=1:48, labels=genome10$V1, cex.lab=0.1)
axis(2, at=c(0.0,0.2,0.4,0.6,0.8,1.0))
plot(genome10$V2 ~ genome10$V3, axes=FALSE, xlab="Sample ID", ylab="Fraction of Genome Covered", ylim=c(0,1), col="red", pch=18)
plot(genome10$V2 ~ genome10$V3, axes=FALSE, xlab="Sample ID", ylab="Fraction of Genome Covered", ylim=c(0,1), col="red", pch=19)
axis(1, at=1:48, labels=genome10$V1, cex.lab=0.1)
genome10 <- genome10[with(genome10, order(V2)), ]
genome10$V3 <- 1:48
plot(genome10$V2 ~ genome10$V3, axes=FALSE, xlab="Sample ID", ylab="Fraction of Genome Covered", ylim=c(0,1), col="red", pch=19)
axis(1, at=1:48, labels=genome10$V1, cex.lab=0.1)
axis(2, at=c(0.0,0.2,0.4,0.6,0.8,1.0))
install.packages("outbreaker", dependencies=TRUE)
library(outbreaker)
library(adegenet)
x<-seq(-4,4,length=200)
y<-dnorm(x,mean=0, sd=1)
plot(x,y, type="l", lwd=2)
x<-seq(0,100,length=101)
y<-dnorm(x,mean=50, sd=1)
plot(x,y, type="l", lwd=2)
x<-seq(0,100,length=101)
y<-dnorm(x,mean=50, sd=2)
plot(x,y, type="l", lwd=2)
x<-seq(0,100,length=101)
y<-dnorm(x,mean=50, sd=10)
plot(x,y, type="l", lwd=2)
x<-seq(0,100,length=101)
y<-dnorm(x,mean=50, sd=50)
plot(x,y, type="l", lwd=2)
x<-seq(0,100,length=101)
y<-dnorm(x,mean=50, sd=1)
plot(x,y, type="l", lwd=2)
x<-seq(0,100,length=101)
y<-dnorm(x,mean=50, sd=50)
plot(x,y, type="l", lwd=2)
y
w <- y
w
hist(Fws, breaks=14)
## LOAD REGEX LIBRARY
library(stringr)
## READ IN MULTI-VCF and REMOVE FIRST NINE COLUMNS
data <- read.table("test.vcf", comment.char="#", header=TRUE)
data <- data[ -c(1:9) ]
## EXTRACT RELEVANT READ DEPTH DATA, FIRST MATCH
refCT <- as.data.frame(sapply(data, function(x) str_extract(x, ":[0123456789]+,")))
# The numbers pre-comma are ref counts
# Convert to data frame on the fly
refCT <- sapply(refCT, function(x) str_extract(x, "[0123456789]+"))
# Clean out the extra chars, leaving only numbers
refCT <- apply(refCT, c(1,2), as.numeric)
# Convert to a numeric matrix
altCT <- as.data.frame(sapply(data, function(x) str_extract(x, ",[0123456789]+:")))
# The numbers post-comma are alt counts
# Convert to data frame on the fly
altCT <- sapply(altCT, function(x) str_extract(x, "[0123456789]+"))
# Clean out the extra chars, leaving only numbers
altCT <- apply(altCT, c(1,2), as.numeric)
# Convert to a numeric matrix
## CALCULATE qs, ps, and Hs, THE PROPORTIONS OF EACH ALLELE IN THE POPULATION
ps <- rowSums(refCT)/(rowSums(refCT)+rowSums(altCT))
qs <- rowSums(altCT)/(rowSums(refCT)+rowSums(altCT))
Hs <- mean(2*ps*qs)
# Calculate Hs for each variant and take the mean of all variants
## CALCULATE qw, pw, and Hw, THE PROPORTIONS OF EACH ALLELE IN EACH INDIVIDUAL
totCT <- refCT + altCT
# Make a matrix of total counts
pw <- matrix(, nrow = length(data$BB012), ncol = length(names(data)))
# Set up pw matrix
qw <- matrix(, nrow = length(data$BB012), ncol = length(names(data)))
# Set up qw matrix
Hw <- matrix(, nrow = length(data$BB012), ncol = length(names(data)))
# Set up Hw matrix
for (i in 1:length(names(data))) {
for (j in 1:length(data$BB012)) {
pw[j,i] <- refCT[j,i]/totCT[j,i] # Calculate pw per individual and per allele
qw[j,i] <- altCT[j,i]/totCT[j,i] # Calculate qw per individual and per allele
Hw[j,i] <- 2*pw[j,i]*qw[j,i] # Calculate Hw per individual and per allele
}
}
Hw <- colMeans(Hw)
# Take the column means of Hw matrix, to get a single Hw score for each sample
## CALCULATE Fws
Fws <- 1 - Hw/Hs
## LOAD REGEX LIBRARY
library(stringr)
## READ IN MULTI-VCF and REMOVE FIRST NINE COLUMNS
data <- read.table("test.vcf", comment.char="#", header=TRUE)
data <- data[ -c(1:9) ]
## EXTRACT RELEVANT READ DEPTH DATA, FIRST MATCH
refCT <- as.data.frame(sapply(data, function(x) str_extract(x, ":[0123456789]+,")))
# The numbers pre-comma are ref counts
# Convert to data frame on the fly
refCT <- sapply(refCT, function(x) str_extract(x, "[0123456789]+"))
# Clean out the extra chars, leaving only numbers
refCT <- apply(refCT, c(1,2), as.numeric)
# Convert to a numeric matrix
altCT <- as.data.frame(sapply(data, function(x) str_extract(x, ",[0123456789]+:")))
# The numbers post-comma are alt counts
# Convert to data frame on the fly
altCT <- sapply(altCT, function(x) str_extract(x, "[0123456789]+"))
# Clean out the extra chars, leaving only numbers
altCT <- apply(altCT, c(1,2), as.numeric)
# Convert to a numeric matrix
## CALCULATE qs, ps, and Hs, THE PROPORTIONS OF EACH ALLELE IN THE POPULATION
ps <- rowSums(refCT)/(rowSums(refCT)+rowSums(altCT))
qs <- rowSums(altCT)/(rowSums(refCT)+rowSums(altCT))
Hs <- mean(2*ps*qs)
# Calculate Hs for each variant and take the mean of all variants
## CALCULATE qw, pw, and Hw, THE PROPORTIONS OF EACH ALLELE IN EACH INDIVIDUAL
totCT <- refCT + altCT
# Make a matrix of total counts
pw <- matrix(, nrow = length(data$BB012), ncol = length(names(data)))
# Set up pw matrix
qw <- matrix(, nrow = length(data$BB012), ncol = length(names(data)))
# Set up qw matrix
Hw <- matrix(, nrow = length(data$BB012), ncol = length(names(data)))
# Set up Hw matrix
for (i in 1:length(names(data))) {
for (j in 1:length(data$BB012)) {
pw[j,i] <- refCT[j,i]/totCT[j,i] # Calculate pw per individual and per allele
qw[j,i] <- altCT[j,i]/totCT[j,i] # Calculate qw per individual and per allele
Hw[j,i] <- 2*pw[j,i]*qw[j,i] # Calculate Hw per individual and per allele
}
}
Hw <- colMeans(Hw)
# Take the column means of Hw matrix, to get a single Hw score for each sample
## CALCULATE Fws
Fws <- 1 - Hw/Hs
Hw
myFunction <- function(x)
result <- x*3
return(result)
myFunction <- function(x) {
result <- x*3
return(result)
}
myFunction(3)
## Function Practice
myFunction <- function(x) {
result <- x*3
#return(result)
}
myFunction(3)
result
## Function Practice
myFunction <- function(input, output) {
output <- input*3
return(output)
}
myFunction(x)
myFunction(x, var)
var
myFunction(x, data1)
data1
## Function Practice
myFunction <- function(input) {
result <- input*3
return(result)
}
myFunction(4)
value <- myFunction(4)
value
## Function Practice
myFunction <- function(input) {
green <- input*3
green*3
}
myFunction(3)
mean
mean()
?mean
intervals <- read.table("~/Desktop/intervals.txt", quote="\"")
View(intervals)
hist(intervals$V1)
hist(intervals$V1, breaks-10)
hist(intervals$V1, breaks=10)
hist(intervals$V1, breaks=20)
hist(intervals$V1, breaks=30)
hist(intervals$V1, breaks=40)
hist(intervals$V1, breaks=20)
hist(intervals$V1, breaks=20, xlim=c(0,80))
hist(intervals$V1, breaks=30, xlim=c(0,80))
hist(intervals$V1, breaks=20, xlim=c(0,80))
CLIN_A01_TAAGGCG.TAGATCG_L001 <- read.delim("~/Desktop/CLIN_A01_TAAGGCG-TAGATCG_L001.kraken", header=FALSE)
View(CLIN_A01_TAAGGCG.TAGATCG_L001)
View(CLIN_A01_TAAGGCG.TAGATCG_L001)
data <- CLIN_A01_TAAGGCG.TAGATCG_L001
View(data)
length(data$V3)
length(data$V3[data$V3 = 470])
length(data$V3[data$V3 == 470])
length(data$V3[data$V3 == 470]) / length(data$V3)
?pdf
pf_cam_pca
library(adegenet)
library(stringr)
## Function to create a genlight object from
## STRUCTURE file. VCF->STR using PGDSpider2
genlight.maker <- function(infile) {
table <- read.table(infile, skip=1, na.strings="-9") # read in data, missing is "-9" in str format
sorted <- table[order(table[,1]),] # sort
inds <- sorted$V1 # grab the indiv names
pops <- sorted$V2 # grab the pop names
sorted <- sorted[-c(1,2)] # remove ind and pop columns from data frame
genlight <- new("genlight", sorted) # convert data frame into genlight object
indNames(genlight) <- inds # add back individual information
ploidy(genlight) <- 1 # add back population information
return(genlight)
}
## Function to assign samples to pops
## based on a list of their names
pop.definer <- function(ind_names) {
library(stringr)
kp <- as.numeric(str_detect(ind_names, "BB"))*1 # assign KP pop number
bb <- as.numeric(str_detect(ind_names, "KP"))*2 # assign BB pop number
om <- as.numeric(str_detect(ind_names, "OM"))*3 # assign OM pop number
sn <- as.numeric(str_detect(ind_names, "SN"))*3 # assign SN pop number
tb <- as.numeric(str_detect(ind_names, "TB"))*3 # assign TB pop number
srr <- as.numeric(str_detect(ind_names, "SRR"))*4 # assign SRR pop number
err <- as.numeric(str_detect(ind_names, "ERR"))*4 # assign ERR pop number
pops <- kp + bb + om + sn + tb + srr + err
return(pops)
}
# Function to mark hi IC50 samples, given a vector of samples and of IC50s
ic50.marker <- function(ind_names, hi_ic50s) {
library(stringr)
ic <- as.numeric(str_detect(ind_names, paste(hi_ic50s, sep = "", collapse = "|")))
return(ic)
}
## Function to record eigenplots
eig.plotter <- function(pca) {
barplot(pca$eig, xlab = "", ylab = "Variance")
}
## Function to record PCAs
pca.plotter <- function(pca, pops, x, y) {
plot(jitter(pca$scores[,y], factor=300) ~ jitter(pca$scores[,x], factor=300),
col=pops,
pch=19,
axes=FALSE,
xlab=paste("PC", x, " - ", round(pca$eig[x]/sum(pca$eig)*100), "% of the Variance", sep = ""),
ylab=paste("PC", y, " - ", round(pca$eig[y]/sum(pca$eig)*100), "% of the Variance", sep = ""),
)
axis(1)
axis(2)
}
pf_cam_gl <- genlight.maker("/run/user/1001/gvfs/sftp:host=kure.unc.edu,user=prchrist/proj/julianog/users/ChristianP/cambodiaWGS/adegenet/our_goods_pf.pass.str") # make genlight
pf_cam_pops <- pop.definer(indNames(pf_cam_gl)) # define pops OR
pf_cam_pca <- glPca(pf_cam_gl) # calculate PCA
pf_cam_pca
library(pegas)
args(read.vcf)
loci <- read.vcf("/run/user/1001/gvfs/sftp:host=kure.unc.edu,user=prchrist/proj/julianog/users/ChristianP/cambodiaWGS/pf/variants/our_goods_UG.pass.vcf", nloci=100)
View(loci)
gl_test <- as.genlight(loci)
class(loci)
install.packages(c("ade4", "adegenet", "ape", "chron", "codetools", "colorspace", "evaluate", "formatR", "ggplot2", "highr", "httpuv", "igraph", "knitr", "manipulate", "markdown", "MASS", "mime", "pegas", "phangorn", "plyr", "PopGenome", "R6", "Rcpp", "rmarkdown", "R.utils", "scales", "shiny", "stringr"))
install.packages(c("ade4", "adegenet", "ape", "chron", "codetools",
install.packages(c("ade4", "adegenet", "ape", "chron", "codetools", "colorspace", "evaluate", "formatR", "ggplot2", "highr", "httpuv", "igraph", "knitr", "manipulate", "markdown", "MASS", "mime", "pegas", "phangorn", "plyr", "PopGenome", "R6", "Rcpp", "rmarkdown", "R.utils", "scales", "shiny", "stringr"))
library(adegenet)
install.packages("adegenet")
library(adegenet)
install.packages("adegenet")
install.packages("dplyr")
install.packages("dplyr")
updateR()
setwd("~/Desktop")
exp <- read.table("list_of_miotto_experiments.txt")
exp <- read.table("list_of_miotto_experiments.txt", header = TRUE)
names(exp)
head(exp)
exp[exp$library_layout == "PAIRED",]
exp[,exp$library_layout == "PAIRED"]
paired <- exp[exp$library_layout == "PAIRED",]
dim(paired)
paired$sample_accession
paired$secondary_sample_accession
exp$secondary_sample_accession
clear
ERP <- read.table("ERP000190.txt")
ERP <- read.table("ERP000190.txt", header = TRUE)
ERS <- read.table("ERS_nums_3", header = TRUE)
dim(ERS)
dim(ERP)
new <- merge(ERS, ERP, by = "secondary_sample_accession")
dim(new)
new$secondary_sample_accession
merged <- merge(ERS, ERP, by = "secondary_sample_accession")
write(merged, file = "list_of_miotto_experiments2.txt")
write.table(merged, file = "list_of_miotto_experiments2.txt")
paired <- merged[merged$library_layout == "PAIRED",]
dim(paired)
dim(merged)
merged$library_layout
paired$library_layout
write.table(paired, file = "list_of_miotto_experiments.txt")
write.table(paired, file = "list_of_miotto_experiments.txt", quote = FALSE)
?write.table
write.table(paired, file = "list_of_miotto_experiments.txt", quote = FALSE, sep = "\t")
paired$secondary_sample_accession
paired <- read.table("list_of_miotto_experiments.txt", header=TRUE)
dim(paired)
paired$secondary_sample_accession
ERP <- read.table("ERP000190.txt", header = TRUE)
ERP$secondary_sample_accession
ERP <- read.table("ERP000190.txt", header = TRUE)
dim(ERP)
ERS <- read.table("ERS_nums_3", header = TRUE)
dim(ERS)
merged <- merge(ERP, ERS, by = "secondary_sample_accession")
dim(merged)
merged$secondary_sample_accession
ERS$secondary_sample_accession %in% ERP$secondary_sample_accession
as.factor(ERS$secondary_sample_accession %in% ERP$secondary_sample_accession)
as.numeric(ERS$secondary_sample_accession %in% ERP$secondary_sample_accession)
sum(as.numeric(ERS$secondary_sample_accession %in% ERP$secondary_sample_accession))
ERS$secondary_sample_accession %in% ERP$secondary_sample_accession
ERS$secondary_sample_accession !%in% ERP$secondary_sample_accession
ERS[ERS$secondary_sample_accession %in% ERP$secondary_sample_accession,]
dim(ERS[ERS$secondary_sample_accession %in% ERP$secondary_sample_accession,])
length(ERS[ERS$secondary_sample_accession %in% ERP$secondary_sample_accession,])
length(ERS[!ERS$secondary_sample_accession %in% ERP$secondary_sample_accession,])
ERS[!ERS$secondary_sample_accession %in% ERP$secondary_sample_accession,]
merged <- merge(ERS, ERP, by = "secondary_sample_accession")
dim(merged)
## Remove the 9 single-end libraries
paired <- merged[merged$library_layout == "PAIRED",]
dim(paired)
## write output file
write.table(paired, file = "list_of_miotto_experiments.txt", quote = FALSE, sep = "\t")
paired <- read.table("list_of_miotto_experiments.txt", header=TRUE)
paired$secondary_sample_accession
setwd("/run/user/1001/gvfs/sftp:host=kure.unc.edu,user=prchrist/proj/julianog/users/ChristianP/cambodiaWGS/extraPops/Miotto2013")
asiaERS <- read.table("asiaERS.txt", header = TRUE)
?write.table
write.table(asia$fastq_ftp, file = "miottoAsiaPointers.txt", quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
asiaERS$secondary_sample_accession %in% paired$secondary_sample_accession
sum(as.numeric(asiaERS$secondary_sample_accession %in% paired$secondary_sample_accession))
dim(asia)
dim(asiaERS)
nrow(asiaERS)
nrow(asiaERS) - sum(as.numeric(asiaERS$secondary_sample_accession %in% paired$secondary_sample_accession))
dim(asia)
asia <- merge(paired, asiaERS, by = "secondary_sample_accession")
dim(asia)
asia$secondary_sample_accession
names(asiaERS)
names(paired)
paired$fastq_ftp
strsplit(paired$fastq_ftp, ";")
strsplit(paired$fastq_ftp, "\;")
strsplit(as.character(paired$fastq_ftp), ";")
unlist(strsplit(as.character(paired$fastq_ftp), ";"))
